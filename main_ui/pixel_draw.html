<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=overlays-content">
<meta name="apple-mobile-web-app-capable" content="yes"> 
<script src="base_utils.js"></script>
<script src="ColorPicker.js"></script>
<script src="pixel_draw.js"></script>
<script src="asm_gfx.js"></script>
<script>

const PX_WIDTH = 64
const PX_HEIGHT = 32

let clock_canvas =  null

let running_id = 1
function add_select(parent, label, values, init_value, cb)
{
    let lbl = null
    if (label !== null) {
        lbl = add_elem(parent, 'label', 'combo_label')
        lbl.innerText = label
    }
    const sel = add_elem(parent, 'select', 'combo_sel')
    const id = 'sel_' + running_id++;
    sel.setAttribute('id', id)
    if (lbl)
        lbl.setAttribute('for', id)
    for(let v of values) {
        const opt = add_elem(sel, 'option', 'combo_opt')
        opt.setAttribute('value', v.value)
        opt.innerText = v.text
    }
    sel.value = init_value
    sel.addEventListener('change', ()=>{ cb(sel.value) } )
    return sel
}

function add_num_input(parent, label, init_val, cb)
{
    if (label != null) {
        const lbl = add_elem(parent, 'label', 'num_in_label')
        lbl.innerText = label
    }
    const cont = add_elem(parent, 'div', 'num_in_cont')
    const minus_btn = add_elem(cont, 'div', ['num_in_minus', 'num_in_btn'])
    minus_btn.innerHTML = '&ndash;'

    const inp = add_elem(cont, 'input', 'num_input')
    inp.setAttribute('type', 'number')
    inp.setAttribute('readonly', true)
    inp.value = init_val
    inp.addEventListener('change', ()=>{ cb(inp.value) } )

    const plus_btn = add_elem(cont, 'div', ['num_in_plus', 'num_in_btn'])
    plus_btn.innerText = '+'

    minus_btn.addEventListener('click', ()=>{ inp.value = parseInt(inp.value) - 1; cb(inp.value) })
    plus_btn.addEventListener('click', ()=>{ inp.value = parseInt(inp.value) + 1; cb(inp.value) })
    return inp
}

function add_checkbox_input(parent, label, init_val, cb)
{
    const cont = add_elem(parent, 'div', 'in_check_cont')
    const inp = add_elem(cont, 'input', 'in_checkbox')
    inp.setAttribute('type', 'checkbox')
    const lbl = add_elem(cont, 'label', 'in_check_label')
    lbl.innerText = label

    const id = 'check_' + running_id++;
    inp.setAttribute('id', id)
    lbl.setAttribute('for', id)

    inp.checked = init_val
    inp.addEventListener('change', ()=>{ cb(inp.checked) })
}

var FONT_OPT = null
function font_opts() {
    if (FONT_OPT !== null)
        return FONT_OPT
    const font_strs = Module.gfx_get_fonts()
    FONT_OPT = [{value:-1, text:'Default'}]
    for(let i = 0; i < font_strs.size(); ++i)
        FONT_OPT.push({value:i, text:font_strs.get(i)})
    return FONT_OPT
}

class Color
{
    constructor(r, g, b)
    {
        this.r = r
        this.g = g
        this.b = b
    }
    set(c) {
        this.r = c.r
        this.g = c.g
        this.b = c.b
    }
}

class TextBlock
{
    constructor(text, font_index, x, y)
    {
        this.text = text
        this.font_index = font_index
        this.x = x
        this.y = y
        this.color = new Color(0, 128, 255)
    }
    draw(gfx) {
        gfx.set_font(this.font_index)
        gfx.set_text_color(this.color.r, this.color.g, this.color.b)
        gfx.print_str_at(this.x, this.y, this.text)
    }

    add_ui(ctrl, display_cb) 
    {
        const ctrl_line1 = add_elem(ctrl, 'div', 'ctrl_line')
        const col_in = add_elem(ctrl_line1, 'input', 'clock_col_in')
        col_in.setAttribute('readonly', true)
        ColorEditBox.create_at(col_in, 300, (c)=>{ 
            this.color.set(c) 
            display_cb()
        }, {}, ColorPicker.make_hex(this.color, true))

        add_select(ctrl_line1, null, font_opts(), this.font_index, (value)=>{
            this.font_index = parseInt(value)
            display_cb()
        })

        const ctrl_line2 = add_elem(ctrl, 'div', 'ctrl_line_last')
        add_num_input(ctrl_line2, null, this.x, (value)=>{
            this.x = value
            display_cb()
        })
        add_num_input(ctrl_line2, null, this.y, (value)=>{
            this.y = value
            display_cb()
        })


    }
}

const DAY_NAMES = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]

class ClockPanel
{
    constructor()
    {
        this.text1 = new TextBlock("20:23:45", 5, 1, 1)
        this.text2 = new TextBlock("Fri 20/10/2023", -1, 0, 20)
        this.show_seconds = true
        this.show_day = true
        this.back_color = new Color(0,0,0)
    }

    start_time(display_cb) {
        this.update_time(display_cb)
        window.setInterval(()=>{ this.update_time(display_cb) }, 1000)
    }

    update_time(display_cb)
    {
        const d = new Date()
        let min = d.getMinutes()
        if (min < 10)
            min = "0" + min
        let time = d.getHours() + ":" + min
        if (this.show_seconds) {
            let sec = d.getSeconds()
            if (sec < 10)
                sec = "0" + sec
            time += ":" + sec
        }
        let date = ""
        if (this.show_day) 
            date += DAY_NAMES[d.getDay()] + " "
        date += d.getDate()
        date += "/" + d.getMonth() + "/"
        date += d.getFullYear()
        
        this.text1.text = time
        this.text2.text = date
        display_cb()
    }

    add_ui(ctrl, display_cb)
    {
        const col1 = add_elem(ctrl, 'div', ['t_col', 't_col1'])
        const t1cont = add_elem(col1, 'div', ['t_cont', 't1_cont'])
        this.text1.add_ui(t1cont, display_cb)

        const t2cont = add_elem(col1, 'div', ['t_cont', 't2_cont'])
        this.text2.add_ui(t2cont, display_cb)

        const col2 = add_elem(ctrl, 'div', ['t_col', 't_col2'])
        add_checkbox_input(col2, "Seconds", this.show_seconds, (v)=>{
            this.show_seconds = v
            this.update_time(display_cb)
        })
        add_checkbox_input(col2, "Show Day", this.show_day, (v)=>{
            this.show_day = v
            this.update_time(display_cb)
        })

        const col_in = add_elem(col2, 'input', 'clock_col_in')
        col_in.setAttribute('readonly', true)
        ColorEditBox.create_at(col_in, 300, (c)=>{ 
            this.back_color.set(c) 
            display_cb()
        }, {}, ColorPicker.make_hex(this.back_color, true))
    }

    draw(gfx)
    {
        gfx.set_back_col(this.back_color.r, this.back_color.g, this.back_color.b)
        this.text1.draw(gfx)
        this.text2.draw(gfx)
    }
}

function clock_onload()
{
    const clock = add_elem(body, 'div', 'clock_top')
    const ctrl = add_elem(clock, 'div', 'clock_ctrl')
    const disp = add_elem(clock, 'div', 'clock_disp')
    clock_canvas = new GfxCanvas(PX_WIDTH, PX_HEIGHT, 5, disp, 0, "clock_canvas")
    Module.gfx_init_display(clock_canvas, PX_WIDTH, PX_HEIGHT)

    let panel = null

    const display = ()=>{
        clock_canvas.gfx.clear()
        panel.draw(clock_canvas.gfx)
        clock_canvas.draw()
    }

    panel = new ClockPanel()
    panel.add_ui(ctrl, display)
    panel.start_time(display)


    display()

}

function page_onload()
{
    
    //draw_pixel_onload(body, PX_WIDTH, PX_HEIGHT)
}



function rt_start()
{
    clock_onload()
    

}

Module.onRuntimeInitialized = rt_start

</script>
<link rel="stylesheet" type="text/css" href="pixel_draw.css">

</head>
<body id="body" onload="page_onload()"></body>

</html>